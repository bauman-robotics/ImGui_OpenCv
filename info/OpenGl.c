
В основном под OpenGL понимают API (Интерфейс Программирования Приложений), 
который предоставляет большой набор функций, которые мы можем использовать для управления графикой и изображениями. 
Но на самом деле OpenGL это скорее спецификация, разработанная и поддерживаемая Khronos Group.

Спецификация OpenGL описывает каким будет результат выполнения каждой конкретной функции и что она должна делать. 
А уже реализация этих спецификаций лежит на плечах разработчиков. 

Раньше, использование OpenGL предполагало разработку в Immediate mode (также известен как фиксированный конвейер (fixed function pipeline)),

спецификация указала Immediate mode как устаревший, и начиная с версии 3.2 начала мотивировать программистов использовать Core-profile режим, 
который исключал весь устаревший функционал.
=============================================================
Immediate mode
Core-profile mode 

inxi -G
Graphics:
  Device-1: Intel Haswell-ULT Integrated Graphics driver: i915 v: kernel
  Device-2: Lite-On Integrated Camera driver: uvcvideo type: USB
  Display: wayland server: X.Org v: 23.2.6 with: Xwayland v: 23.2.6
    compositor: gnome-shell v: 46.0 driver: dri: crocus gpu: i915
    resolution: 1600x900~60Hz
  API: EGL v: 1.5 drivers: crocus,swrast
    platforms: wayland,x11,surfaceless,device
  API: OpenGL v: 4.6 compat-v: 4.5 vendor: intel mesa v: 24.0.9-0ubuntu0.1
    renderer: Mesa Intel HD Graphics 4400 (HSW GT2)
=============================================================
sudo apt-get install mesa-utils

glxinfo | grep "OpenGL version"
OpenGL version string: 4.6 (Compatibility Profile) Mesa 24.0.9-0ubuntu0.1
=============================================================

Часть 1.2 — Создание окна

GLFW

GLFW — это библиотека, написанная на C, специально нацеленная для предоставления OpenGL самого необходимого для отрисовки контента на экран. 
Она позволяет нам создать контекст, определить параметры окна и работать с пользовательским вводом, а это все что там сейчас нужно.

CMake — это инструмент для генерации файлов Проекта/Решения для IDE, выбранного пользователем 
(Visual Studio, Code::Blocks, Eclipse) из набора исходных кодов и CMake скриптов. 

Линковка
http://www.opengl-tutorial.org/miscellaneous/building-your-own-c-application/

Для использования GLFW нам также требуется его связать с нашим проектом. Это делаеться, указанием, 
что мы хотим использовать glfw3.lib в настройках линковщика, но наш проект все еще не знает, где искать glfw3.lib 

указать название линкуемой библиотеки, в нашем случае это glfw3.lib и добавляем мы ее в поле Additional Dependencies

На Linux системах вам требуется использовать libGL.so библиотеку, использовав флаг -lGL в настройках линковщика. 

GLEW расшифровывается как OpenGL Extension Wrangler Library
существуют библиотеки реализующие эту динамическую линковку и одной из самых популярных библиотек является GLEW


Статическая линковка означает, что библиотека будет интегрирована с исполняемым файлом во время компиляции
#define GLEW_STATIC

Динамическая линковка осуществляется посредством .dll и .so файлов, 
осуществляя разделение кода библиотеки и кода приложения, уменьшая размер исполняемого файла и упрощая обновление библиотеки. 


Для пользователей Linux, собирающих проект с помощью GCC в сборке могут помочь следующие ключи:

-lGLEW -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi. 


//Инициализация GLFW
glfwInit();

Первые 2 аргумента функции glViewport — это позиция нижнего левого угла окна. 
Третий и четвертый — это ширина и высота отрисовываемого окна в px, которые мы получаем напрямую из GLFW. 

// //Выключение возможности изменения размера окна
// glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);


Прежде чем мы начнем что-либо отрисовывать нам надо еще кое что сделать. 
Нам нужно сообщить OpenGL размер отрисовываемого окна, чтобы OpenGL знал, 
как мы хотим отображать данные и координаты относительно окна.

int width, height;
glfwGetFramebufferSize(window, &width, &height);
  
glViewport(0, 0, width, height);

Первые 2 аргумента функции glViewport — это позиция нижнего левого угла окна. 
Третий и четвертый — это ширина и высота отрисовываемого окна в px, которые мы получаем напрямую из GLFW. 

while(!glfwWindowShouldClose(window))
{
    glfwPollEvents();
    glfwSwapBuffers(window);
}
Функция glfwPollEvents проверяет были ли вызваны какие либо события (вроде ввода с клавиатуры или перемещение мыши) 

Функция glfwSwapBuffers заменяет цветовой буфер (большой буфер, содержащий значения цвета для каждого пикселя в GLFW окне), 
который использовался для отрисовки во время текущей итерации и показывает результат на экране.
Двойная буферизация
======================================================================================

learnopengl. Урок 1.4 — Hello Triangle

В OpenGL все находится в 3D пространстве, но при этом экран и окно — это 2D матрица из пикселей. 
Поэтому большая часть работы OpenGL — это преобразование 3D координат в 2D пространство для отрисовки на экране. 

Процесс преобразования 3D координат в 2D координаты управляется графическим конвейером OpenGL. 
Графический конвейер можно разделить на 2 большие части: первая часть преобразовывает 3D координаты в 2D координаты, 
а вторая часть преобразовывает 2D координаты в цветные пиксели.

большинство современных GPU имеют тысячи маленьких процессоров для быстрой обработки данных 
графического конвейера с помощью запуска большого количества маленьких программ на каждом этапе конвейера. 
Эти маленькие программы называются шейдерами.
